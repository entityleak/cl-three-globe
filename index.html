<!DOCTYPE html>
<html>
<head>
  <style>
    body {
      margin: 0;
      background: #000;
      color: white;
      font-family: Arial, sans-serif;
    }

    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 100;
      background: rgba(0,0,0,0.7);
      padding: 15px;
      border-radius: 5px;
    }

    .control-group {
      margin-bottom: 10px;
    }

    label {
      display: inline-block;
      width: 120px;
      font-size: 12px;
    }

    input[type="range"] {
      width: 100px;
    }

    select {
      background: #333;
      color: white;
      border: 1px solid #555;
    }
  </style>

  <script type="importmap">{ "imports": {
    "three": "https://esm.sh/three",
    "three/": "https://esm.sh/three/"
  }}</script>
</head>

<body>
  <div id="globeViz"></div>

  <div id="controls">
    <h3>Halftone Controls</h3>

    <div class="control-group">
      <label>Pattern Size:</label>
      <input type="range" id="patternSize" min="2" max="32" value="8" step="1">
      <span id="patternSizeValue">---</span>
    </div>

    <div class="control-group">
      <label>Threshold:</label>
      <input type="range" id="threshold" min="0" max="1" value="0.5" step="0.05">
      <span id="thresholdValue">---</span>
    </div>

    <div class="control-group">
      <label>Contrast:</label>
      <input type="range" id="contrast" min="0.5" max="3" value="1" step="0.1">
      <span id="contrastValue">---</span>
    </div>

    <div class="control-group">
      <label>Exposure:</label>
      <input type="range" id="exposure" min="-2" max="2" value="0" step="0.1">
      <span id="exposureValue">---</span>
    </div>

    <div class="control-group">
      <label>Blending:</label>
      <input type="range" id="blending" min="0" max="1" value="1" step="0.1">
      <span id="blendingValue">---</span>
    </div>

    <div class="control-group">
      <label>Pattern Type:</label>
      <select id="patternType">
        <option value="dots" selected>Dots Procedural</option>
        <option value="lines">Lines</option>
        <option value="grid">Grid</option>
        <option value="noise">Noise</option>
        <option value="dotsTexture">Dots Texture</option>
      </select>
    </div>

    <div class="control-group">
      <label>Greyscale:</label>
      <input type="checkbox" id="greyscale" checked>
    </div>

    <div class="control-group">
      <label>Invert:</label>
      <input type="checkbox" id="invert">
    </div>

    <div class="control-group">
      <label>Enable Effect:</label>
      <input type="checkbox" id="enable" checked>
    </div>

    <div class="control-group">
      <label>Black Overlay:</label>
      <input type="range" id="blackOverlay" min="0" max="1" value="0" step="0.05">
      <span id="blackOverlayValue">0.85</span>
    </div>
  </div>

  <script type="module">
    import ThreeGlobe from 'https://esm.sh/three-globe@2.44.0?external=three';
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { TrackballControls } from 'three/addons/controls/TrackballControls.js';    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';

    // Load dot pattern texture
    const dotPatternTexture = new THREE.TextureLoader().load('/static/dot_149.png');
    dotPatternTexture.wrapS = THREE.RepeatWrapping;
    dotPatternTexture.wrapT = THREE.RepeatWrapping;
    dotPatternTexture.minFilter = THREE.NearestFilter;
    dotPatternTexture.magFilter = THREE.NearestFilter;

    // Pattern-based dithering shader (matching imageProcessor.js functionality)
    const HalftoneShader = {
      uniforms: {
        tDiffuse: { value: null },
        tPattern: { value: dotPatternTexture }, // Dot pattern texture
        resolution: { value: new THREE.Vector2() },
        patternSize: { value: 5.0 },
        threshold: { value: 1 },
        contrast: { value: 1.0 },
        exposure: { value: 0.5 },
        invert: { value: false },
        greyscale: { value: true },
        blending: { value: 1.0 },
        disable: { value: false },
        patternType: { value: 4.0 }, // 0=dots procedural, 1=lines, 2=grid, 3=noise, 4=dots texture
        blackOverlay: { value: 0.8 } // 0=transparent, 1=full black
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform sampler2D tPattern;
        uniform vec2 resolution;
        uniform float patternSize;
        uniform float threshold;
        uniform float contrast;
        uniform float exposure;
        uniform bool invert;
        uniform bool greyscale;
        uniform float blending;
        uniform bool disable;
        uniform float patternType;
        uniform float blackOverlay;

        varying vec2 vUv;

        float luma(vec3 color) {
          return dot(color, vec3(0.299, 0.587, 0.114));
        }

        // Generate procedural dither patterns
        float generateDotPattern(vec2 coord) {
          vec2 center = fract(coord) - 0.5;
          return 1.0 - smoothstep(0.0, 0.5, length(center));
        }

        float generateLinePattern(vec2 coord) {
          return sin(coord.y * 6.28318) * 0.5 + 0.5;
        }

        float generateGridPattern(vec2 coord) {
          vec2 grid = abs(fract(coord) - 0.5);
          return smoothstep(0.4, 0.5, max(grid.x, grid.y));
        }

        float generateNoisePattern(vec2 coord) {
          return fract(sin(dot(coord, vec2(12.9898, 78.233))) * 43758.5453);
        }

        void main() {
          if (disable) {
            gl_FragColor = texture2D(tDiffuse, vUv);
            return;
          }

          vec4 tex = texture2D(tDiffuse, vUv);

          // Apply exposure and contrast adjustments (like imageProcessor.js)
          vec3 color = tex.rgb;

          // Apply exposure first (brightness adjustment)
          float exposureFactor = pow(2.0, exposure);
          color *= exposureFactor;

          // Apply contrast (around midpoint 0.5)
          color = ((color - 0.5) * contrast) + 0.5;
          color = clamp(color, 0.0, 1.0);

          // Get pixel brightness
          float brightness = greyscale ? luma(color) : (color.r + color.g + color.b) / 3.0;

          // Get pattern threshold
          vec2 patternCoord = vUv * resolution / patternSize;
          float patternThreshold;

          if (patternType < 0.5) {
            patternThreshold = generateDotPattern(patternCoord);
          } else if (patternType < 1.5) {
            patternThreshold = generateLinePattern(patternCoord);
          } else if (patternType < 2.5) {
            patternThreshold = generateGridPattern(patternCoord);
          } else if (patternType < 3.5) {
            patternThreshold = generateNoisePattern(patternCoord);
          } else {
            // Texture-based dot pattern (dot_149.png)
            vec2 textureCoord = vUv * resolution / patternSize;
            vec4 patternSample = texture2D(tPattern, textureCoord);
            patternThreshold = patternSample.r; // Use red channel as threshold
          }

          patternThreshold *= threshold;

          // Apply dithering: if brightness > pattern threshold, use white; else black
          float ditherResult = brightness > patternThreshold ? 1.0 : 0.0;

          // Apply inversion if enabled
          if (invert) {
            ditherResult = 1.0 - ditherResult;
          }

          vec3 ditherColor = vec3(ditherResult);
          vec3 finalColor = mix(color, ditherColor, blending);

          // Apply black overlay on top of everything
          finalColor = mix(finalColor, vec3(0.0), blackOverlay);

          gl_FragColor = vec4(finalColor, tex.a);
        }
      `
    };

    // Load ring data from JSON file
    const response = await fetch('./rings-data.json');
    const gData = await response.json();

    // Create globe with custom animation disabled
    const Globe = new ThreeGlobe({ animateIn: false })
      .globeImageUrl('/static/earth-combined.jpg')
      .bumpImageUrl('//cdn.jsdelivr.net/npm/three-globe/example/img/earth-topology.png')
      .ringsData(gData)
      .ringColor(d => {
        // Create color interpolator that fades out
        const baseColor = d.color;
        return t => baseColor.replace(/[\d.]+\)$/, `${1-t})`);
      })
      .ringMaxRadius('maxR')
      .ringPropagationSpeed('propagationSpeed')
      .ringRepeatPeriod('repeatPeriod')
      .atmosphereColor('#7E7E7E')
      .atmosphereAltitude(0.5);

    // Custom intro animation
    const targetRotation = (100 * Math.PI) / 180; // Show North America (lng ~-100)
    const targetCameraZ = 650; // Final camera distance (matches camera.position.z below)
    const introAnimation = {
      active: true,
      startTime: Date.now(),
      duration: 2800, // 1 second
      initialRotation: Math.PI * 2 + targetRotation, // Start rotated 360 degrees + target
      targetRotation: targetRotation, // End rotation to show North America
      initialScale: 0.001, // Start very small
      initialCameraZ: 1200, // Start camera far away
      targetCameraZ: targetCameraZ // End camera distance
    };

    // Setup renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio));
    document.getElementById('globeViz').appendChild(renderer.domElement);

    // Setup scene
    const scene = new THREE.Scene();
    scene.add(Globe);
    scene.add(new THREE.AmbientLight(0xcccccc, Math.PI));
    scene.add(new THREE.DirectionalLight(0xffffff, 0.6 * Math.PI));

    // Setup camera
    const camera = new THREE.PerspectiveCamera(
      30, // FOV in degrees (default is 50, lower = more telephoto/zoomed)
      window.innerWidth / window.innerHeight, // aspect ratio
      0.1, // near clipping plane
      1000 // far clipping plane
    );
    camera.updateProjectionMatrix();
    camera.position.z = 800;

    // Add camera controls - restrict to horizontal rotation only
    const cameraControls = new TrackballControls(camera, renderer.domElement);
    cameraControls.minDistance = targetCameraZ;
    cameraControls.maxDistance = targetCameraZ+0.0001;
    cameraControls.rotateSpeed = 2;
    cameraControls.zoomSpeed = 0.8;
    cameraControls.enablePan = false;

    // Lock vertical rotation - keep camera on horizontal plane
    // cameraControls.minPolarAngle = Math.PI / 2; // 90 degrees
    // cameraControls.maxPolarAngle = Math.PI / 2; // 90 degrees

    // Create separate scene for rings (render on top of post-processing)
    const ringsScene = new THREE.Scene();
    const ringsContainer = new THREE.Group();
    ringsScene.add(ringsContainer);

    // Add invisible occluder sphere to hide rings on far side of globe
    const occluderGeometry = new THREE.SphereGeometry(100, 64, 64);
    const occluderMaterial = new THREE.MeshBasicMaterial({
      colorWrite: false, // Don't write color, only depth
      depthWrite: true   // Write to depth buffer to occlude rings
    });
    const occluderSphere = new THREE.Mesh(occluderGeometry, occluderMaterial);
    ringsScene.add(occluderSphere);

    // Setup post-processing
    const composer = new EffectComposer(renderer);
    const renderPass = new RenderPass(scene, camera);
    composer.addPass(renderPass);

    const halftonePass = new ShaderPass(HalftoneShader);
    halftonePass.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
    composer.addPass(halftonePass);

    // Controls
    const controls = {
      patternSize: document.getElementById('patternSize'),
      threshold: document.getElementById('threshold'),
      contrast: document.getElementById('contrast'),
      exposure: document.getElementById('exposure'),
      blending: document.getElementById('blending'),
      patternType: document.getElementById('patternType'),
      greyscale: document.getElementById('greyscale'),
      invert: document.getElementById('invert'),
      enable: document.getElementById('enable'),
      blackOverlay: document.getElementById('blackOverlay')
    };

    const values = {
      patternSizeValue: document.getElementById('patternSizeValue'),
      thresholdValue: document.getElementById('thresholdValue'),
      contrastValue: document.getElementById('contrastValue'),
      exposureValue: document.getElementById('exposureValue'),
      blendingValue: document.getElementById('blendingValue'),
      blackOverlayValue: document.getElementById('blackOverlayValue')
    };

    // Control event listeners
    controls.patternSize.addEventListener('input', (e) => {
      const value = parseFloat(e.target.value);
      halftonePass.uniforms.patternSize.value = value;
      values.patternSizeValue.textContent = value;
    });

    controls.threshold.addEventListener('input', (e) => {
      const value = parseFloat(e.target.value);
      halftonePass.uniforms.threshold.value = value;
      values.thresholdValue.textContent = value.toFixed(2);
    });

    controls.contrast.addEventListener('input', (e) => {
      const value = parseFloat(e.target.value);
      halftonePass.uniforms.contrast.value = value;
      values.contrastValue.textContent = value.toFixed(1);
    });

    controls.exposure.addEventListener('input', (e) => {
      const value = parseFloat(e.target.value);
      halftonePass.uniforms.exposure.value = value;
      values.exposureValue.textContent = value.toFixed(1);
    });

    controls.blending.addEventListener('input', (e) => {
      const value = parseFloat(e.target.value);
      halftonePass.uniforms.blending.value = value;
      values.blendingValue.textContent = value.toFixed(1);
    });

    controls.patternType.addEventListener('change', (e) => {
      const patternMap = { 'dots': 0, 'lines': 1, 'grid': 2, 'noise': 3, 'dotsTexture': 4 };
      halftonePass.uniforms.patternType.value = patternMap[e.target.value];
    });

    controls.greyscale.addEventListener('change', (e) => {
      halftonePass.uniforms.greyscale.value = e.target.checked;
    });

    controls.invert.addEventListener('change', (e) => {
      halftonePass.uniforms.invert.value = e.target.checked;
    });

    controls.enable.addEventListener('change', (e) => {
      halftonePass.uniforms.disable.value = !e.target.checked;
    });

    controls.blackOverlay.addEventListener('input', (e) => {
      const value = parseFloat(e.target.value);
      halftonePass.uniforms.blackOverlay.value = value;
      values.blackOverlayValue.textContent = value.toFixed(2);
    });

    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
      halftonePass.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
    });

    // Helper function to convert lat/lng to 3D position (matches three-globe's polar2Cartesian)
    function latLngToVector3(lat, lng, radius) {
      const phi = (90 - lat) * Math.PI / 180;
      const theta = (90 - lng) * Math.PI / 180;
      const phiSin = Math.sin(phi);
      const x = radius * phiSin * Math.cos(theta);
      const y = radius * Math.cos(phi);
      const z = radius * phiSin * Math.sin(theta);
      return new THREE.Vector3(x, y, z);
    }

    // Create logos with connecting lines
    const logoGroup = new THREE.Group();
    ringsScene.add(logoGroup);

    const logoObjects = []; // Store logo data for animation updates

    function createLogos() {
      gData.forEach((d) => {
        if (d.logo) {
          // Get position on globe surface
          const globePos = latLngToVector3(d.lat, d.lng, 100);

          // Create line (will be updated each frame)
          const lineGeometry = new THREE.BufferGeometry();
          const positions = new Float32Array(6); // 2 points * 3 coordinates
          lineGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
          const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, opacity: 0.5, transparent: true });
          const line = new THREE.Line(lineGeometry, lineMaterial);
          logoGroup.add(line);

          // Create sprite for logo
          const textureLoader = new THREE.TextureLoader();
          textureLoader.load(d.logo, (texture) => {
            // Preserve texture quality
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;

            const spriteMaterial = new THREE.SpriteMaterial({
              map: texture,
              sizeAttenuation: true, // Size changes with distance
              depthTest: true,
              depthWrite: false
            });
            const sprite = new THREE.Sprite(spriteMaterial);

            // Preserve aspect ratio based on texture dimensions
            const aspectRatio = texture.image.width / texture.image.height;
            const size = 20; // Base size (reduced from 50)
            sprite.scale.set(size * aspectRatio, size, 1);

            logoGroup.add(sprite);

            // Store for updates
            logoObjects.push({
              globePos: globePos,
              sprite: sprite,
              line: line,
              data: d
            });
          });
        }
      });
    }

    createLogos();

    // Update logo positions to extend vertically in screen space
    function updateLogoPositions() {
      if (logoObjects.length === 0) return;

      // Update all matrices first
      scene.updateMatrixWorld(true);
      ringsScene.updateMatrixWorld(true);
      logoGroup.updateMatrixWorld(true);

      logoObjects.forEach(({ globePos, sprite, line }, index) => {
        // Get world position of the point on globe (globePos is already in logoGroup local space)
        const worldGlobePos = globePos.clone();
        worldGlobePos.applyMatrix4(logoGroup.matrixWorld);

        // Get camera's up vector in world space (always points "up" in screen space)
        const cameraUp = new THREE.Vector3(0, 1, 0).applyQuaternion(camera.quaternion);

        // Determine if we should go up or down based on position relative to camera
        const upComponent = worldGlobePos.clone().sub(camera.position).dot(cameraUp);
        const offsetDirection = upComponent > 0 ? 1 : -1;

        // Offset in world space along camera up direction
        const offsetDistance = 50; // World units
        const worldLogoPos = worldGlobePos.clone().add(cameraUp.clone().multiplyScalar(offsetDistance * offsetDirection));

        // Convert world logo position to local space of logoGroup
        const inverseMatrix = new THREE.Matrix4().copy(logoGroup.matrixWorld).invert();
        const localLogoPos = worldLogoPos.clone().applyMatrix4(inverseMatrix);

        // Set sprite position
        sprite.position.copy(localLogoPos);

        // Update line (both positions in local space)
        const positions = line.geometry.attributes.position.array;
        positions[0] = globePos.x;
        positions[1] = globePos.y;
        positions[2] = globePos.z;
        positions[3] = localLogoPos.x;
        positions[4] = localLogoPos.y;
        positions[5] = localLogoPos.z;
        line.geometry.attributes.position.needsUpdate = true;
      });
    }

    // Helper function to move rings to separate scene
    function moveRingsToSeparateScene() {
      // Sync the container with Globe's transform
      ringsContainer.position.copy(Globe.position);
      ringsContainer.rotation.copy(Globe.rotation);
      ringsContainer.scale.copy(Globe.scale);

      // Sync logo group with Globe's transform
      logoGroup.position.copy(Globe.position);
      logoGroup.rotation.copy(Globe.rotation);
      logoGroup.scale.copy(Globe.scale);

      const ringsToMove = [];
      Globe.traverse((obj) => {
        if (obj.__globeObjType === 'ring') {
          ringsToMove.push({ ring: obj, parent: obj.parent });
        }
      });

      ringsToMove.forEach(({ ring, parent }) => {
        if (!parent) return;

        // Store local transform
        const localPos = ring.position.clone();
        const localRot = ring.rotation.clone();
        const localScale = ring.scale.clone();

        // Move to ringsContainer
        parent.remove(ring);
        ringsContainer.add(ring);

        // Restore local transform
        ring.position.copy(localPos);
        ring.rotation.copy(localRot);
        ring.scale.copy(localScale);
      });
    }

    // Auto-rotation
    const autoRotateSpeed = -0.01; // Degrees per frame

    // Animation loop
    function animate() {
      cameraControls.update();

      // Custom intro animation
      if (introAnimation.active) {
        const elapsed = Date.now() - introAnimation.startTime;
        const progress = Math.min(elapsed / introAnimation.duration, 1);

        // Easing function (ease out quad)
        const eased = 1 - Math.pow(1 - progress, 3);

        // Animate globe scale (zoom in)
        const scale = introAnimation.initialScale + (1 - introAnimation.initialScale) * eased;
        Globe.scale.set(scale, scale, scale);

        // Animate globe rotation (spin from initial to target)
        Globe.rotation.y = introAnimation.initialRotation - (introAnimation.initialRotation - introAnimation.targetRotation) * eased;

        // Animate camera zoom
        camera.position.z = introAnimation.initialCameraZ - (introAnimation.initialCameraZ - introAnimation.targetCameraZ) * eased;

        // End animation when complete
        if (progress >= 1) {
          introAnimation.active = false;
          Globe.scale.set(1, 1, 1);
          Globe.rotation.y = introAnimation.targetRotation;
          camera.position.z = introAnimation.targetCameraZ;
        }
      } else {
        // Auto-rotate the globe (only after intro)
        Globe.rotation.y += autoRotateSpeed * Math.PI / 180;
      }

      // Move rings to separate scene and sync transforms every frame
      moveRingsToSeparateScene();

      // Update logo positions to follow screen space
      updateLogoPositions();

      // Render main scene with post-processing
      composer.render();

      // Render rings on top without post-processing
      renderer.autoClear = false;
      renderer.clearDepth();
      renderer.render(ringsScene, camera);
      renderer.autoClear = true;

      requestAnimationFrame(animate);
    }

    animate();
  </script>
</body>
</html>