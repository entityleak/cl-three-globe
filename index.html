<!DOCTYPE html>
<html>
<head>
  <style>
    body {
      margin: 0;
      background: #000;
      color: white;
      font-family: Arial, sans-serif;
    }

    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 100;
      background: rgba(0,0,0,0.7);
      padding: 15px;
      border-radius: 5px;
    }

    .control-group {
      margin-bottom: 10px;
    }

    label {
      display: inline-block;
      width: 120px;
      font-size: 12px;
    }

    input[type="range"] {
      width: 100px;
    }

    select {
      background: #333;
      color: white;
      border: 1px solid #555;
    }
  </style>

  <script type="importmap">{ "imports": {
    "three": "https://esm.sh/three",
    "three/": "https://esm.sh/three/"
  }}</script>
</head>

<body>
  <div id="globeViz"></div>

  <div id="controls">
    <h3>Halftone Controls</h3>

    <div class="control-group">
      <label>Pattern Size:</label>
      <input type="range" id="patternSize" min="2" max="32" value="8" step="1">
      <span id="patternSizeValue">3</span>
    </div>

    <div class="control-group">
      <label>Threshold:</label>
      <input type="range" id="threshold" min="0" max="1" value="0.5" step="0.05">
      <span id="thresholdValue">0.5</span>
    </div>

    <div class="control-group">
      <label>Contrast:</label>
      <input type="range" id="contrast" min="0.5" max="3" value="1" step="0.1">
      <span id="contrastValue">1.1</span>
    </div>

    <div class="control-group">
      <label>Exposure:</label>
      <input type="range" id="exposure" min="-2" max="2" value="0" step="0.1">
      <span id="exposureValue">-1.0</span>
    </div>

    <div class="control-group">
      <label>Blending:</label>
      <input type="range" id="blending" min="0" max="1" value="1" step="0.1">
      <span id="blendingValue">1.0</span>
    </div>

    <div class="control-group">
      <label>Pattern Type:</label>
      <select id="patternType">
        <option value="dots" selected>Dots</option>
        <option value="lines">Lines</option>
        <option value="grid">Grid</option>
        <option value="noise">Noise</option>
      </select>
    </div>

    <div class="control-group">
      <label>Greyscale:</label>
      <input type="checkbox" id="greyscale" checked>
    </div>

    <div class="control-group">
      <label>Invert:</label>
      <input type="checkbox" id="invert">
    </div>

    <div class="control-group">
      <label>Enable Effect:</label>
      <input type="checkbox" id="enable" checked>
    </div>
  </div>

  <script type="module">
    import ThreeGlobe from 'https://esm.sh/three-globe@2.44.0?external=three';
    import * as THREE from 'three';
    import { TrackballControls } from 'three/addons/controls/TrackballControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';

    // Pattern-based dithering shader (matching imageProcessor.js functionality)
    const HalftoneShader = {
      uniforms: {
        tDiffuse: { value: null },
        resolution: { value: new THREE.Vector2() },
        patternSize: { value: 3.0 },
        threshold: { value: 0.5 },
        contrast: { value: 1.1 },
        exposure: { value: -1.0 },
        invert: { value: false },
        greyscale: { value: true },
        blending: { value: 1.0 },
        disable: { value: false },
        patternType: { value: 0.0 } // 0=dots, 1=lines, 2=grid, 3=noise
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform vec2 resolution;
        uniform float patternSize;
        uniform float threshold;
        uniform float contrast;
        uniform float exposure;
        uniform bool invert;
        uniform bool greyscale;
        uniform float blending;
        uniform bool disable;
        uniform float patternType;

        varying vec2 vUv;

        float luma(vec3 color) {
          return dot(color, vec3(0.299, 0.587, 0.114));
        }

        // Generate procedural dither patterns
        float generateDotPattern(vec2 coord) {
          vec2 center = fract(coord) - 0.5;
          return 1.0 - smoothstep(0.0, 0.5, length(center));
        }

        float generateLinePattern(vec2 coord) {
          return sin(coord.y * 6.28318) * 0.5 + 0.5;
        }

        float generateGridPattern(vec2 coord) {
          vec2 grid = abs(fract(coord) - 0.5);
          return smoothstep(0.4, 0.5, max(grid.x, grid.y));
        }

        float generateNoisePattern(vec2 coord) {
          return fract(sin(dot(coord, vec2(12.9898, 78.233))) * 43758.5453);
        }

        void main() {
          if (disable) {
            gl_FragColor = texture2D(tDiffuse, vUv);
            return;
          }

          vec4 tex = texture2D(tDiffuse, vUv);

          // Apply exposure and contrast adjustments (like imageProcessor.js)
          vec3 color = tex.rgb;

          // Apply exposure first (brightness adjustment)
          float exposureFactor = pow(2.0, exposure);
          color *= exposureFactor;

          // Apply contrast (around midpoint 0.5)
          color = ((color - 0.5) * contrast) + 0.5;
          color = clamp(color, 0.0, 1.0);

          // Get pixel brightness
          float brightness = greyscale ? luma(color) : (color.r + color.g + color.b) / 3.0;

          // Get pattern threshold
          vec2 patternCoord = vUv * resolution / patternSize;
          float patternThreshold;

          if (patternType < 0.5) {
            patternThreshold = generateDotPattern(patternCoord);
          } else if (patternType < 1.5) {
            patternThreshold = generateLinePattern(patternCoord);
          } else if (patternType < 2.5) {
            patternThreshold = generateGridPattern(patternCoord);
          } else {
            patternThreshold = generateNoisePattern(patternCoord);
          }

          patternThreshold *= threshold;

          // Apply dithering: if brightness > pattern threshold, use white; else black
          float ditherResult = brightness > patternThreshold ? 1.0 : 0.0;

          // Apply inversion if enabled
          if (invert) {
            ditherResult = 1.0 - ditherResult;
          }

          vec3 ditherColor = vec3(ditherResult);
          vec3 finalColor = mix(color, ditherColor, blending);

          gl_FragColor = vec4(finalColor, tex.a);
        }
      `
    };

    // Generate random data for globe
    const N = 15;
    const gData = [...Array(N).keys()].map(() => ({
      lat: (Math.random() - 0.5) * 180,
      lng: (Math.random() - 0.5) * 360,
      maxR: Math.random() * 20 + 3,
      propagationSpeed: (Math.random() - 0.5) * 20 + 1,
      repeatPeriod: Math.random() * 2000 + 200
    }));

    const colorInterpolator = t => `rgba(255,100,50,${1-t})`;

    // Create globe
    const Globe = new ThreeGlobe()
      .globeImageUrl('/static/earth-dark.jpg')
      .bumpImageUrl('//cdn.jsdelivr.net/npm/three-globe/example/img/earth-topology.png')
      .ringsData(gData)
      .ringColor(() => colorInterpolator)
      .ringMaxRadius('maxR')
      .ringPropagationSpeed('propagationSpeed')
      .ringRepeatPeriod('repeatPeriod');

    // Setup renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio));
    document.getElementById('globeViz').appendChild(renderer.domElement);

    // Setup scene
    const scene = new THREE.Scene();
    scene.add(Globe);
    scene.add(new THREE.AmbientLight(0xcccccc, Math.PI));
    scene.add(new THREE.DirectionalLight(0xffffff, 0.6 * Math.PI));

    // Setup camera
    const camera = new THREE.PerspectiveCamera();
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    camera.position.z = 500;

    // Add camera controls
    const tbControls = new TrackballControls(camera, renderer.domElement);
    tbControls.minDistance = 101;
    tbControls.rotateSpeed = 5;
    tbControls.zoomSpeed = 0.8;

    // Setup post-processing
    const composer = new EffectComposer(renderer);
    const renderPass = new RenderPass(scene, camera);
    composer.addPass(renderPass);

    const halftonePass = new ShaderPass(HalftoneShader);
    halftonePass.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
    composer.addPass(halftonePass);

    // Controls
    const controls = {
      patternSize: document.getElementById('patternSize'),
      threshold: document.getElementById('threshold'),
      contrast: document.getElementById('contrast'),
      exposure: document.getElementById('exposure'),
      blending: document.getElementById('blending'),
      patternType: document.getElementById('patternType'),
      greyscale: document.getElementById('greyscale'),
      invert: document.getElementById('invert'),
      enable: document.getElementById('enable')
    };

    const values = {
      patternSizeValue: document.getElementById('patternSizeValue'),
      thresholdValue: document.getElementById('thresholdValue'),
      contrastValue: document.getElementById('contrastValue'),
      exposureValue: document.getElementById('exposureValue'),
      blendingValue: document.getElementById('blendingValue')
    };

    // Control event listeners
    controls.patternSize.addEventListener('input', (e) => {
      const value = parseFloat(e.target.value);
      halftonePass.uniforms.patternSize.value = value;
      values.patternSizeValue.textContent = value;
    });

    controls.threshold.addEventListener('input', (e) => {
      const value = parseFloat(e.target.value);
      halftonePass.uniforms.threshold.value = value;
      values.thresholdValue.textContent = value.toFixed(2);
    });

    controls.contrast.addEventListener('input', (e) => {
      const value = parseFloat(e.target.value);
      halftonePass.uniforms.contrast.value = value;
      values.contrastValue.textContent = value.toFixed(1);
    });

    controls.exposure.addEventListener('input', (e) => {
      const value = parseFloat(e.target.value);
      halftonePass.uniforms.exposure.value = value;
      values.exposureValue.textContent = value.toFixed(1);
    });

    controls.blending.addEventListener('input', (e) => {
      const value = parseFloat(e.target.value);
      halftonePass.uniforms.blending.value = value;
      values.blendingValue.textContent = value.toFixed(1);
    });

    controls.patternType.addEventListener('change', (e) => {
      const patternMap = { 'dots': 0, 'lines': 1, 'grid': 2, 'noise': 3 };
      halftonePass.uniforms.patternType.value = patternMap[e.target.value];
    });

    controls.greyscale.addEventListener('change', (e) => {
      halftonePass.uniforms.greyscale.value = e.target.checked;
    });

    controls.invert.addEventListener('change', (e) => {
      halftonePass.uniforms.invert.value = e.target.checked;
    });

    controls.enable.addEventListener('change', (e) => {
      halftonePass.uniforms.disable.value = !e.target.checked;
    });

    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
      halftonePass.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
    });

    // Animation loop
    function animate() {
      tbControls.update();
      composer.render();
      requestAnimationFrame(animate);
    }

    animate();
  </script>
</body>
</html>